substitutions:
  device_name: thermostat-c3
  friendly_name: Thermostat C3

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  min_version: 2024.6.0
  project:
    name: custom.thermostat_cascade
    version: "1.0"

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:
api:
ota:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

captive_portal:

one_wire:
  - platform: gpio
    pin: GPIO4

globals:
  - id: inner_i
    type: float
    restore_value: no
    initial_value: "0.0"
  - id: inner_prev_e
    type: float
    restore_value: no
    initial_value: "0.0"
  - id: outer_i
    type: float
    restore_value: no
    initial_value: "0.0"
  - id: outer_prev_e
    type: float
    restore_value: no
    initial_value: "0.0"
  - id: heater_pwm
    type: float
    restore_value: no
    initial_value: "0.0"
  - id: sensor2_failed
    type: bool
    restore_value: no
    initial_value: "false"
  - id: alarm_state
    type: bool
    restore_value: no
    initial_value: "false"
  - id: temp2_prev
    type: float
    restore_value: no
    initial_value: "0.0"
  - id: temp2_rate
    type: float
    restore_value: no
    initial_value: "0.0"

switch:
  - platform: gpio
    id: heater_1_relay
    name: "Heater 1 Relay"
    pin: GPIO6
    restore_mode: ALWAYS_OFF

  - platform: gpio
    id: heater_2_relay
    name: "Heater 2 Relay"
    pin: GPIO7
    restore_mode: ALWAYS_OFF

  - platform: gpio
    id: fan_relay
    name: "Fan Relay"
    pin: GPIO8
    restore_mode: ALWAYS_OFF

  - platform: gpio
    id: buzzer_relay
    name: "Alarm Buzzer"
    pin: GPIO10
    restore_mode: ALWAYS_OFF

number:
  - platform: template
    id: target_external
    name: "Target External Temperature"
    unit_of_measurement: "째C"
    min_value: 10
    max_value: 90
    step: 0.5
    restore_value: true
    optimistic: true
    initial_value: 45

  - platform: template
    id: max_process_temp
    name: "Max Process Temperature"
    unit_of_measurement: "째C"
    min_value: 20
    max_value: 120
    step: 1
    restore_value: true
    optimistic: true
    initial_value: 80

sensor:
  - platform: dallas_temp
    address: 0x0000000000000001
    name: "Sensor 1 External"
    id: temp_external
    update_interval: 2s

  - platform: dallas_temp
    address: 0x0000000000000002
    name: "Sensor 2 Process"
    id: temp_process
    update_interval: 2s
    on_value:
      then:
        - lambda: |-
            if (id(temp2_prev) == 0.0f) {
              id(temp2_prev) = x;
            }
            id(temp2_rate) = (x - id(temp2_prev)) / 2.0f;
            id(temp2_prev) = x;

  - platform: dallas_temp
    address: 0x0000000000000003
    name: "Sensor 3 Volume Top"
    id: temp_top
    update_interval: 2s

  - platform: dallas_temp
    address: 0x0000000000000004
    name: "Sensor 4 Volume Bottom"
    id: temp_bottom
    update_interval: 2s

  - platform: template
    id: temp_process_backup
    name: "Backup Process Temperature"
    unit_of_measurement: "째C"
    lambda: |-
      return (id(temp_top).state + id(temp_bottom).state) * 0.5f;
    update_interval: 2s

  - platform: template
    id: temp_volume_delta
    name: "Volume Temperature Delta"
    unit_of_measurement: "째C"
    lambda: |-
      return fabsf(id(temp_top).state - id(temp_bottom).state);
    update_interval: 2s

binary_sensor:
  - platform: template
    id: process_sensor_fault
    name: "Sensor 2 Fault"
    lambda: |-
      return (!id(temp_process).has_state()) || (isnan(id(temp_process).state));
    on_state:
      then:
        - lambda: |-
            id(sensor2_failed) = x;

  - platform: template
    id: overtemp_alarm
    name: "Overtemperature Alarm"
    lambda: |-
      float t = id(sensor2_failed) ? id(temp_process_backup).state : id(temp_process).state;
      return t > id(max_process_temp).state;

interval:
  - interval: 5s
    then:
      - lambda: |-
          // Cascade PID: outer loop by external sensor, inner loop by process sensor.
          const float dt = 5.0f;

          const float outer_kp = 0.80f;
          const float outer_ki = 0.015f;
          const float outer_kd = 0.08f;

          const float inner_kp = 8.0f;
          const float inner_ki = 0.20f;
          const float inner_kd = 2.0f;

          const float measured_outer = id(temp_external).state;
          const float target_outer = id(target_external).state;
          const float e_outer = target_outer - measured_outer;

          id(outer_i) += e_outer * dt;
          id(outer_i) = std::max(-40.0f, std::min(40.0f, id(outer_i)));
          const float d_outer = (e_outer - id(outer_prev_e)) / dt;
          id(outer_prev_e) = e_outer;

          float inner_setpoint = measured_outer +
                                 outer_kp * e_outer +
                                 outer_ki * id(outer_i) +
                                 outer_kd * d_outer;

          inner_setpoint = std::max(20.0f, std::min(id(max_process_temp).state - 2.0f, inner_setpoint));

          float measured_inner = id(sensor2_failed) ? id(temp_process_backup).state : id(temp_process).state;
          const float e_inner = inner_setpoint - measured_inner;

          id(inner_i) += e_inner * dt;
          id(inner_i) = std::max(-100.0f, std::min(100.0f, id(inner_i)));
          const float d_inner = (e_inner - id(inner_prev_e)) / dt;
          id(inner_prev_e) = e_inner;

          float u = inner_kp * e_inner + inner_ki * id(inner_i) + inner_kd * d_inner;
          id(heater_pwm) = std::max(0.0f, std::min(1.0f, u / 100.0f));

          // Main heater by time-proportional control.
          if (id(heater_pwm) > 0.25f) {
            id(heater_1_relay).turn_on();
          } else {
            id(heater_1_relay).turn_off();
          }

          // Reserve heater logic: activate if heating is weak (low dT/dt) and high demand.
          if ((id(heater_pwm) > 0.70f && id(temp2_rate) < 0.02f) || id(sensor2_failed)) {
            id(heater_2_relay).turn_on();
          } else {
            id(heater_2_relay).turn_off();
          }

          // Fan control for temperature equalization by volume gradient.
          if (id(temp_volume_delta).state > 1.5f) {
            id(fan_relay).turn_on();
          } else if (id(temp_volume_delta).state < 0.7f) {
            id(fan_relay).turn_off();
          }

          // Alarm logic: sensor fault or overtemperature.
          id(alarm_state) = id(sensor2_failed) || id(overtemp_alarm).state;
          if (id(alarm_state)) {
            id(buzzer_relay).turn_on();
            id(heater_1_relay).turn_off();
            id(heater_2_relay).turn_off();
          } else {
            id(buzzer_relay).turn_off();
          }

text_sensor:
  - platform: template
    name: "Control Mode"
    lambda: |-
      if (id(sensor2_failed)) {
        return {"RESERVE_SENSOR_MODE"};
      }
      return {"NORMAL_MODE"};
    update_interval: 5s
